# 异或运算

[TOC]



#### 1. 异或运算符

在数字逻辑中，逻辑算符异或（`exclusive or`）是对两个运算元的一种逻辑分析类型，符号为 XOR 或 ⊕（编程语言中常用 `^`）

|   名称   | 符号 |
| :------: | :--: |
| 数学符号 |  ⊕   |
| 英文简称 | xor  |
| 程序符号 |  ^   |

英语的 exclusive 意思是"专有的，独有的"，可以理解为 XOR 是更单纯的 OR 运算。



我们知道，OR 运算的运算子有两种情况，计算结果为 `true`。

1. 一个为 true，另一个为 false;
2. 两个都为 true。

上面两种情况，有时候需要明确区分，所以引入了 XOR。



XOR 排除了第二种情况，只有第一种情况（一个运算子为 `true`，另一个为 `false`）才会返回 true，所以可以看成是更单纯的 OR 运算。也就是说， **XOR 主要用来判断两个值是否不同。**



异或也叫**半加运算**，其运算法则相当于不带进位的二进制加法：二进制下用 1 表示 `true`，0 表示 `false`。它的运算真值表如下：

```shell
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
```

可以看出 ，这些法则与加法是相同的，只是**不带进位**，所以异或常被认作不进位加法。



------



#### 2. 运算定律

- 交换律：**A⊕B = B⊕A**
- 结合律：**A⊕(B⊕C) = (A⊕B)⊕C**
- 恒等律：**X⊕0 = X**
- 归零律：**X⊕X = 0**
- 自反律：**A⊕B⊕B = A⊕(B⊕B) = A⊕0 = A**



------



#### 3. 应用场景



##### 3.1 **快速比较两数值是否想等**

根据归零律：a^a=0, 可写出如下函数：

```kotlin
fun equals(a: Int, b: Int): Boolean {
    return a xor b == 0
}
```



##### 3.2 **检验一个数字中1的个数的奇偶（奇偶校验）**

> 求 10100001 中 1 的个数?
>
> ***1 ^ 0 ^ 1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 = 1***
> 按位进行异或运算得到的结果等于 1，结果为奇数，得到的结果为 0，结果为偶数



##### 3.3 **不用中间变量，交换两个变量的值**

给定整数 a 和 b，不用额外变量交换两个整数的值。针对该问题，可以用以下三行代码来交换 a 和 b 的值（a0 与 b0 表示原始值）：

```javascript
function swap(a, b) {
    a = a ^ b; // ① a = a0 ^ b0，b = b0
    b = a ^ b; // ② a = a0 ^ b0，b = a0 ^ b0 ^ b0 = a0
    a = a ^ b; // ③ a = a0 ^ b0 ^ a0 = b0，b = a0
}
```

这里只要是应用了自反律：**A⊕B⊕B = A⊕(B⊕B) = A⊕0 = A** 可以推出相关结果。



##### 3.4 只出现一次的数字

面试题：一个整型数组里除了一个数字之外，其他的数字都出现了两次，找出这个数字。



利用异或运算的**归零律**：**X⊕X = 0** 和**恒等律**：**X⊕0 = X**

> 对于数组{a, a, b, b, c, c, d}，找出只出现了一次的数字d
>
> ```javascript
> a^a^b^b^c^c^d = 0^0^0d = 0^d = d
> ```
>
> 时间复杂度为O(N), 空间复杂度为O(1)

代码实现如下：

```javascript
function singleNumber(nums) {
    let ans = 0;
    for(const num of nums) {
        ans ^= num;
    }
    return ans;
}
```



##### 3.5  找缺少或者重复数字



1.面试题： 一个数组包含 n-1 个成员，这些成员是 1 到 n 之间的整数，且没有重复，请找出缺少的那个数字。



利用异或运算的**归零律**：**X⊕X = 0** 和**恒等律**：**X⊕0 = X**

> 把所有数组成员（A[0] 一直到 A[n-2]）与 1 到 n 的整数全部放在一起，进行异或运算。
>
> ```javascript
> A[0] ^ A[1] ^ ... ^ A[n-2] ^ 1 ^ 2 ^ ... ^ n
> ```
>
> 上面这个式子中，每个数组成员都会出现两次，相同的值进行异或运算就会得到 0。只有缺少的那个数字出现一次，所以最后得到的就是这个值。





2.面试题： 一个数组包含 n+1 个成员，这些成员是 1 到 n 之间的整数。只有一个成员出现了两次，其他成员都只出现一次，请找出重复出现的那个数字。

> 与上面一样，把所有数组成员（A[0] 一直到 A[n]）与 1 到 n 的整数全部放在一起，进行异或运算。
>
> ```javascript
> A[0] ^ A[1] ^ ... ^ A[n] ^ 1 ^ 2 ^ ... ^ n
> ```
>
> 上面这个式子中，每个数组成员都会出现两次，相同的值进行异或运算就会得到 0。只有重复的那个数字出现三次，所以最后得到的就是这个值。



##### 3.6  比特序列加密

计算机的操作对象并不是文字，而是由 0 和 1 排列而成的比特序列。**无论是文字、图片、声音、视频还是程序，在计算机中都是用比特序列来表示的。执行加密操作的程序，就是将表示明文的比特序列转换为表示密文的比特序列。**



利用异或运算的自反律: **A⊕B⊕B = A⊕(B⊕B) = A⊕0 = A**

```javascript
明文 XOR 密钥 --> 密文
密文 XOR 密钥 --> 明文
```

只要选择一个合适的密钥，仅仅使用 XOR 就可以实现一个高强度的密码。



但此方法在目前的密码学中并不怎么实用，主要有以下问题：

1. 安全性问题

   XOR 加密的安全性相对较差。它的主要问题是加密密钥长度等于明文长度，而且每个位上的加密密钥都是对应位的异或。因此，一旦加密密钥被泄露，攻击者可以轻松解密密文，从而破坏数据的保密性。

2. 重复性问题

   由于相同的加密密钥总是产生相同的密文，如果明文中有重复的部分，对应的密文也会是重复的，这样容易导致密码分析，从而破解加密。

3. 密钥管理

   XOR 加密需要安全地管理密钥。由于加密和解密使用相同的密钥，必须确保密钥的保密性。密钥的管理和分发成为一个复杂的问题。

4. 不支持分组加密

   XOR 加密通常用于对单个数据块进行加密，而不支持分组加密。在实际应用中，数据通常被划分为多个块，然后分别加密。这种分组加密可以更好地保护数据，并提供更多的加密模式和更复杂的算法。
